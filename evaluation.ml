(* 
                         MiniML -- Evaluation
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime, generated by a runtime error in
   the interpreter *)
exception EvalError of string ;;
  
(* Exception for evaluator runtime, generated by an explicit `raise`
   construct in the object language *)
exception EvalException ;;

(*......................................................................
  Environments and values 
 *)

module type ENV = sig
    (* the type of environments *)
    type env
    (* the type of values stored in environments *)
    type value =
      | Val of expr
      | Closure of (expr * env)
   
    (* empty () -- Returns an empty environment *)
    val empty : unit -> env

    (* close expr env -- Returns a closure for `expr` and its `env` *)
    val close : expr -> env -> value

    (* lookup env varid -- Returns the value in the `env` for the
       `varid`, raising an `Eval_error` if not found *)
    val lookup : env -> varid -> value

    (* extend env varid loc -- Returns a new environment just like
       `env` except that it maps the variable `varid` to the `value`
       stored at `loc`. This allows later changing the value, an
       ability used in the evaluation of `letrec`. To make good on
       this, extending an environment needs to preserve the previous
       bindings in a physical, not just structural, way. *)
    val extend : env -> varid -> value ref -> env

    (* env_to_string env -- Returns a printable string representation
       of environment `env` *)
    val env_to_string : env -> string
                                 
    (* value_to_string ?printenvp value -- Returns a printable string
       representation of a value; the optional flag `printenvp`
       (default: `true`) determines whether to include the environment
       in the string representation when called on a closure *)
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : ENV =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    let empty () : env = []

    let close (exp : expr) (env : env) : value =
      Closure (exp, env)

    let lookup (env : env) (varname : varid) : value =
      !(List.assoc varname env)

    let extend (env : env) (varname : varid) (loc : value ref) : env =
      let removed = (List.remove_assoc varname env) in
      (varname, loc) :: removed

    let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with
      | Val expr -> exp_to_abstract_string expr
      | Closure (expr, env) ->
         if printenvp
           then "{" ^ (exp_to_abstract_string expr)
                ^ ", " ^ (env_to_string env) ^ "}"
         else exp_to_abstract_string expr

    and env_to_string (env : env) : string =
      match env with
      | (name, value) :: tl ->
         "[" ^ name ^ ": " ^ (value_to_string !value) ^ "], "
         ^ (env_to_string tl)
      | [] -> "END\n"
  end
;;


(*......................................................................
  Evaluation functions

  Each of the evaluation functions below evaluates an expression `exp`
  in an environment `env` returning a result of type `value`. We've
  provided an initial implementation for a trivial evaluator, which
  just converts the expression unchanged to a `value` and returns it,
  along with "stub code" for three more evaluators: a substitution
  model evaluator and dynamic and lexical environment model versions.

  Each evaluator is of type `expr -> Env.env -> Env.value` for
  consistency, though some of the evaluators don't need an
  environment, and some will only return values that are "bare
  values" (that is, not closures). *)

(* The TRIVIAL EVALUATOR, which leaves the expression to be evaluated
   essentially unchanged, just converted to a value for consistency
   with the signature of the evaluators. *)
   
let eval_t (exp : expr) (_env : Env.env) : Env.value =
  (* coerce the expr, unchanged, into a value *)
  Env.Val exp ;;

(* The SUBSTITUTION MODEL evaluator and helper functions *)

let eval_unop (op : unop) (v : Env.value) : Env.value =
  match op, v with
  | Negate, Env.Val (Num x) -> Env.Val (Num (~-x))
  | F_Negate, Env.Val (Float x) -> Env.Val (Float (~-.x))
  | _ -> raise (EvalError "unop is only for negating nums") ;;

let eval_binop (op : binop) (v1 : Env.value) (v2 : Env.value) =
  match op, v1, v2 with
  | Plus, Env.Val (Num n1), Env.Val (Num n2) ->
     Env.Val (Num (n1 + n2))
  | F_Plus, Env.Val (Float f1), Env.Val (Float f2) ->
     Env.Val (Float (f1 +. f2))
  | Plus, _, _
  | F_Plus, _, _ -> raise (EvalError "can not add non-num values")
  | Minus, Env.Val (Num n1), Env.Val (Num n2) ->
     Env.Val (Num (n1 - n2))
  | F_Minus, Env.Val (Float f1), Env.Val (Float f2) ->
     Env.Val (Float (f1 -. f2))
  | Minus, _, _
  | F_Minus, _, _ ->
     raise (EvalError "can not subtract non-num values")
  | Times, Env.Val (Num n1), Env.Val (Num n2) ->
     Env.Val (Num (n1 * n2))
  | F_Times, Env.Val (Float f1), Env.Val (Float f2) ->
     Env.Val (Float (f1 *. f2))
  | Times, _, _
  | F_Times, _, _ ->
     raise (EvalError "can not multiply non-num values")
  | Equals, Env.Val (Num n1), Env.Val (Num n2) ->
     Env.Val (Bool (n1 = n2))
  | Equals, Env.Val (Float f1), Env.Val (Float f2) ->
     Env.Val (Bool (f1 = f2))
  | LessThan, Env.Val (Num n1), Env.Val (Num n2) ->
     Env.Val (Bool (n1 < n2))
  | LessThan, Env.Val (Float f1), Env.Val (Float f2) ->
     Env.Val (Bool (f1 < f2))
  | _, _, _ -> raise (EvalError "can not compare non-num values");;

let eval_cond (exp : Env.value) : bool =
  match exp with
  | Val (Bool (b)) -> b
  | Val _ -> raise (EvalError "can only evaluate booleans in conditions")
  | Closure _ -> raise (EvalError "can not eval truth on closures")

let env_to_exp (v : Env.value) : Expr.expr =
  match v with
  | Val exp -> exp
  | Closure (exp, _) -> exp ;;

let rec eval_s (exp : expr) (env : Env.env) : Env.value =
match exp with
  | Var _ | Num _ | Float _ | Bool _ | Fun _ | Unassigned -> Env.Val exp
  | Unop (op, exp1) -> eval_unop op (eval_s exp1 env)
  | Binop (op, exp1, exp2) -> eval_binop op (eval_s exp1 env) (eval_s exp2 env)
  | Conditional (if_exp, then_exp, else_exp) ->
     if eval_cond (eval_s if_exp env) then eval_s then_exp env
     else eval_s else_exp env
  | Let (v_name, def_exp, in_exp) ->
     eval_s (subst v_name (env_to_exp (eval_s def_exp env)) in_exp) env
  | Letrec (v_name, def_exp, in_exp) ->
     eval_s (subst v_name 
                   (subst v_name 
                          (Letrec (v_name,
                                   def_exp, Var (v_name)))
                          def_exp)
                   in_exp) env
  | Raise -> raise EvalException
  | App (exp1, exp2) ->
     match eval_s exp1 env with
     | Env.Val Fun (v_name, exp1) ->
        eval_s (subst v_name (env_to_exp (eval_s exp2 env)) exp1) env
     | _ -> raise (EvalError "Function required to apply to expression") ;;
     
(* The DYNAMICALLY-SCOPED ENVIRONMENT MODEL evaluator -- to be
   completed *)
   
let rec eval_d (exp : expr) (env : Env.env) : Env.value =
  match exp with
  | Num _ | Float _ | Bool _ | Unassigned -> Env.Val exp
  | Var v ->
     (try
        match Env.lookup env v with
        | Env.Val exp -> Env.Val exp
        | Env.Closure (exp, sub_env) -> eval_d exp sub_env
      with
        Not_found -> raise (EvalError ("variable " ^ v ^ " not defined")))
  | Unop (op, exp1) -> eval_unop op (eval_d exp1 env)
  | Binop (op, exp1, exp2) -> eval_binop op (eval_d exp1 env) (eval_d exp2 env)
  | Conditional (if_exp, then_exp, else_exp) ->
     if eval_cond (eval_d if_exp env) then eval_d then_exp env
     else eval_d else_exp env
  | Fun _ -> Env.close exp (Env.empty ())
  | Let (v_name, def_exp, in_exp) ->
     eval_d in_exp (Env.extend env v_name (ref (eval_d def_exp env)))
  | Letrec (v_name, def_exp, in_exp) ->
     let local_env = Env.extend env v_name (ref (Env.Val Unassigned)) in
     let new_def = eval_d def_exp local_env in 
     let local_env' = Env.extend local_env v_name (ref new_def) in
     eval_d in_exp local_env'
  | Raise -> raise EvalException
  | App (exp1, exp2) ->
     match eval_d exp1 env with
     | Env.Closure (Fun (expr, envi), _) ->
        eval_d envi (Env.extend env expr (ref (eval_d exp2 env)))
     | _ -> raise (EvalError "Function required to apply to expression") ;;
  
(* Connecting the evaluators to the external world. The REPL in
   `miniml.ml` uses a call to the single function `evaluate` defined
   here. Initially, `evaluate` is the trivial evaluator `eval_t`. But
   you can define it to use any of the other evaluators as you proceed
   to implement them. (We will directly unit test the four evaluators
   above, not the `evaluate` function, so it doesn't matter how it's
   set when you submit your solution.) *)
   
let evaluate = eval_s ;;
